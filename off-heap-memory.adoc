= Off-heap
By Thomas SCHWENDER
:icons: font
// check https://github.com/Ardemius/personal-wiki/wiki/AsciiDoctor-tips for tips on table of content in GitHub
:toc: macro
:imagesdir: images
:source-highlighter: highlightjs
// the following attributes are specific to the DZSlides backend
:backend: dzslides
:dzslides-style: stormy
:dzslides-transition: fade
:dzslides-fonts: family=Yanone+Kaffeesatz:400,700,200,300&family=Cedarville+Cursive
:dzslides-highlight: monokai

// No preamble, and so, no table of contents accepted in DZSlides. Put in comments the following lines if generating slides with this backend
One document type to handle them all! (documents, blogs, slides, books, etc.)

toc::[]

== Exemple d'utilisation : ActivePivot

* ActivePivot : base de données en mémoire, écrite en Java, très grosse volumétrie, très fortes contraintes de performance +

=== Intérêts

Permet d'outrepasser certaines contraintes inhérentes à Java :

* pas fait pour gérer de très fortes volumétries de données
* le GC n'est pas réellement fait pour gérer des objets +
Pour rappel les fonctions du GC sont :
** de détecter les objets qui ne sont plus référencés (utilisés), et de les effacer
** de déplacer les survivants d'une zone mémoire à l'autre, afin de libérer de la place pour l'affectation des nouveaux objets
Cela convient bien à des objets dont le cycle de vie est court, et pour des JVM de l'ordre de quelques Go.

Par contre, ce principe ne semble pas adapté à des objets lourds et à cycle de vie (très) long. +
Ces derniers vont en effet être régulièrement déplacés d'une zone mémoire à l'autre, ce qui va être d'autant plus pénalisant que les objets sont lourds, et que l'opération de déplacement du GC est bloquante (*VERIFIER DANS QUELS CAS EXACTEMENT*)

Une solution : sauvegarder les données dans une zone mémoire non gérée, non vue, par le GC (appelée mémoire Off-Heap)

=== Comment allouer de la mémoire Off-Heap

Cela passe par l'utilisation de `java.nio.ByteBuffer`.

Les objets instanciés à partir de cette classe vont être stockés dans la Heap. +
Par contre, il va s'agir de "pointeurs", très légers en eux-mêmes, vers une zone mémoire en dehors de la Heap.

Manipuler le contenu de ces objets n'est pas sans contraintes :

* ce contenu n'est accessible que par le principe de sérialisation / désérialisation. +
En effet, ce que Java va stocker dans la mémoire off-heap va être considéré comme des octets, et non des objets. +
Ceci n'est évidemment pas bon en termes de performance.
Par contre, c'est *très performant pour les type primitifs*.

De plus, la perte du pointeur vers le buffer rend ce dernier éligible à la garbage collection.
La mémoire associée au pointeur est libérée au moment de la collecte.

DirectByteBuffer : il y a un overhead, du fait de certaines opérations supplémentaires, comme la détection de l'architecture petit-boutiste (little-endian), ou gros-boutiste de (big-endian) de l'OS sous-jacent.
Pour la solution ActivePivot, la classe (DirectByteBuffer) a été réimplémentée afin de ne pas effectuer ces opérations supplémentaires.
Cette réimplémentaion nécessite l'utilisation de la classe Unsafe

== `sun.misc.Unsafe`

Cette classe permet de manipuler directement la mémoire en Java.

A la base, elle n'est pas censé être utilisée en dehors du jdk.
Son accès est protégé (AJOUTER UNE EXPLICATION), et il faut donc se servir de l'introspection pour pouvoir l'utiliser :

	Field f = Unsafe.class.getDeclaredField("theUnsafe");
	f.setAccessible(true);
	Unsafe unsafe = (Unsafe) f.get(null); 

=== ecriture

Avec `Unsafe`, nous pouvons allouer de la mémoire à un emplacement dont on obtient l'adresse :

	long address = unsafe.allocatememory(1024);

A partir de là, il est possible d'y insérer des données :

	unsafe.putInt(address, 10);

en prenant soin de gérer *manuellement* leur position en mémoire

	unsafe.putChar(address + 4, 'x')

Ici nous avions insérer dans un 1er temps un int, donc 4 octets, donc il faut tenir compte lors de l'ajout du char suivant.

=== lecture
Le même raisonnement s'applique pour la lecture des données


=== Les risques

PRECISER : crash suite à mauvais accès mémoire
Si on essaye d'écrire dans une zone non allouée.

== Resources

* http://www.touilleur-express.fr/2015/01/14/parisjug-soiree-youngblood/ +
Sujet 3 : Faire tourner une JVM avec 4 To de mémoire : yes we can par Gaëlle Guimezanes
Travaille chez QuartetFS, éditeur d'ActivePivot, solution d'analyse multidimensionnelle +
Voir la vidéo https://www.youtube.com/watch?v=Cskt4qtNeEI
* se renseigner sur `sun.misc.Unsafe`
* http://blog.ippon.fr/2011/11/03/java-acces-directs-a-la-memoire-off-heap/
* https://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html[java.nio.ByteBuffer] : surtout la section _Direct vs. non-direct buffers_
* http://mishadoff.com/blog/java-magic-part-4-sun-dot-misc-dot-unsafe/[Utilisation de Unsafe]


  