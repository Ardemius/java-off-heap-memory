= Off-heap
By Thomas SCHWENDER
:icons: font
// check https://github.com/Ardemius/personal-wiki/wiki/AsciiDoctor-tips for tips on table of content in GitHub
:toc: macro
:imagesdir: images
:source-highlighter: highlightjs
// the following attributes are specific to the DZSlides backend
:backend: dzslides
:dzslides-style: stormy
:dzslides-transition: fade
:dzslides-fonts: family=Yanone+Kaffeesatz:400,700,200,300&family=Cedarville+Cursive
:dzslides-highlight: monokai

// No preamble, and so, no table of contents accepted in DZSlides. Put in comments the following lines if generating slides with this backend
One document type to handle them all! (documents, blogs, slides, books, etc.)

toc::[]

== Modèle mémoire en Java

FAIRE UN SCHEMA

* Heap
** Eden Pool
** Survivor Pool
** Tenured Pool

* Non Heap
** Method Area +
This area was previously known as the permanent generation where loaded classes were stored. It has recently been removed from the JVM, and classes are now loaded as metadata to native memory of the underlying OS.
** Native Area +
This area holds references and variables of primitive types.

Expliquer pour la Non Heap (Off Heap) le principe de Thread stack (voir Jenkov)

== Exemple d'utilisation : ActivePivot

* ActivePivot : base de données en mémoire, écrite en Java, très grosse volumétrie, très fortes contraintes de performance +

== Intérêts

Permet d'outrepasser certaines contraintes inhérentes à Java :

* pas fait pour gérer de très fortes volumétries de données
* le GC n'est pas réellement fait pour gérer des objets +
Pour rappel les fonctions du GC sont :
** de détecter les objets qui ne sont plus référencés (utilisés), et de les effacer
** de déplacer les survivants d'une zone mémoire à l'autre, afin de libérer de la place pour l'affectation des nouveaux objets
Cela convient bien à des objets dont le cycle de vie est court, et pour des JVM de l'ordre de quelques Go.

Par contre, ce principe ne semble pas adapté à des objets lourds et à cycle de vie (très) long. +
Ces derniers vont en effet être régulièrement déplacés d'une zone mémoire à l'autre, ce qui va être d'autant plus pénalisant que les objets sont lourds, et que l'opération de déplacement du GC est bloquante (*VERIFIER DANS QUELS CAS EXACTEMENT*)

Une solution : sauvegarder les données dans une zone mémoire non gérée, non vue, par le GC (appelée mémoire Off-Heap)

== Allocation de mémoire en Java

* Tous les objets instanciés à l'aide de `new` sont alloués dans la Heap.
* Non Direct ByteBuffer
* Direct ByteBuffer
* Off Heap


== Comment allouer de la mémoire Off-Heap


Java nio a introduit le principe de mémoire off-heap (java 1.4). Java 7 l’a étendu (JSR-203/NIO2).

Les objets concernés sont les ByteBuffers (java.nio.ByteBuffer) avec allocation directe (maximum de  2 Go par buffer).
Concrètement il s’agit d’un tableau de Bytes qui sera stocké dans la mémoire native.
La nature même du stockage (sous forme binaire) impose une sérialisation/désérialisation des objets.

SYNTHESE DES 2 parties à faire

Cela passe par l'utilisation de la classe `java.nio.ByteBuffer` et de sa méthode `allocateDirect`.

Les objets instanciés à partir de cette classe vont être stockés dans la Heap. +
Par contre, il va s'agir de "pointeurs", très légers en eux-mêmes, vers une zone mémoire en dehors de la Heap.

Manipuler le contenu de ces objets n'est pas sans contraintes :

* ce contenu n'est accessible que par le principe de sérialisation / désérialisation. +
En effet, ce que Java va stocker dans la mémoire off-heap va être considéré comme des octets, et non des objets. +
Ceci n'est évidemment pas bon en termes de performance.

Par contre, c'est *très performant pour les type primitifs*.
On ne met QUE des types primitifs en Off-Heap.
Jenkov: All local variables of primitive types ( boolean, byte, short, char, int, long, float, double) are fully stored on the thread stack and are thus not visible to other threads.

De plus, la perte du pointeur vers le buffer rend ce dernier éligible à la garbage collection.
La mémoire associée au pointeur est libérée au moment de la collecte.

	//Objet léger qui pointe vers la mémoire. 
	ByteBuffer bb = ByteBuffer.allocateDirect(1024);
	 
	bb.putInt(15);
	bb.putChar('a');
	bb.rewind();
	 
	int myInt = bb.getInt();
	char myChar = bb.getChar();

DirectByteBuffer : il y a un overhead, du fait de certaines opérations supplémentaires, comme la détection de l'architecture petit-boutiste (little-endian), ou gros-boutiste de (big-endian) de l'OS sous-jacent.
Pour la solution ActivePivot, la classe (DirectByteBuffer) a été réimplémentée afin de ne pas effectuer ces opérations supplémentaires.
Cette réimplémentaion nécessite l'utilisation de la classe Unsafe

=== Un peu d'histoire...

A la base, Java a plu grâce son garbage collector.
Ce dernier, en gérant la mémoire "automatiquement", a résolu une majorité des bugs que l'on avait historiquement en C et C++.
En effet, en C / C++, on ne peut pas vérifier que le pointeur utilisé est associé à une zone de mémoire réservée.

Java nio a introduit le principe de mémoire off-heap (java 1.4). Java 7 l’a étendu (JSR-203/NIO2).

== `sun.misc.Unsafe`

Cette classe permet de manipuler directement la mémoire en Java.

A la base, elle n'est pas censé être utilisée en dehors du jdk.
Son accès est protégé, et il faut donc se servir de l'introspection pour pouvoir l'utiliser :

	Field f = Unsafe.class.getDeclaredField("theUnsafe");
	f.setAccessible(true);
	Unsafe unsafe = (Unsafe) f.get(null); 

=== ecriture

Avec `Unsafe`, nous pouvons allouer de la mémoire à un emplacement dont on obtient l'adresse :

	long address = unsafe.allocatememory(1024);

A partir de là, il est possible d'y insérer des données :

	unsafe.putInt(address, 10);

en prenant soin de gérer *manuellement* leur position en mémoire

	unsafe.putChar(address + 4, 'x')

Ici nous avions insérer dans un 1er temps un int, donc 4 octets, donc il faut tenir compte lors de l'ajout du char suivant.

=== lecture
Le même raisonnement s'applique pour la lecture des données


=== Les risques

PRECISER : crash suite à mauvais accès mémoire
Si on essaye d'écrire dans une zone non allouée.

l'utilisation de Unsafe nécessite une vérification à chaque montée de version de Java.

=== Cas d'utilisation

memory mapped file : voir Chronicle Queue (anciennement OpenHFT)

== Resources

* http://www.touilleur-express.fr/2015/01/14/parisjug-soiree-youngblood/ +
Sujet 3 : Faire tourner une JVM avec 4 To de mémoire : yes we can par Gaëlle Guimezanes
Travaille chez QuartetFS, éditeur d'ActivePivot, solution d'analyse multidimensionnelle +
Voir la vidéo https://www.youtube.com/watch?v=Cskt4qtNeEI
* se renseigner sur `sun.misc.Unsafe`
* http://blog.ippon.fr/2011/11/03/java-acces-directs-a-la-memoire-off-heap/
* https://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html[java.nio.ByteBuffer] : surtout la section _Direct vs. non-direct buffers_
* http://mishadoff.com/blog/java-magic-part-4-sun-dot-misc-dot-unsafe/[Utilisation de Unsafe]
* http://shekup.blogspot.fr/2011/11/java-runtime-memory-management.html : rechercher ByteBuffer pour un schéma sur la NativeHeap (Off-Heap memory)
* http://www.javacodegeeks.com/2013/08/which-memory-is-faster-heap-or-bytebuffer-or-direct.html : voir les exemples de code dans les commentaires
* voir http://chronicle.software/products/chronicle-queue/ pour un exemple et des explications poussées sur le memory mapped file
* voir sur PluralSight : https://app.pluralsight.com/library/courses/understanding-java-vm-memory-management/table-of-contents
* Livre blanc José Paumard et So@t : Java 8 - Migration et enjeux stratégiques en entreprise : pour l'histoire de Java
* Modèle mémoire :
** http://tutorials.jenkov.com/java-concurrency/java-memory-model.html : explication complète du modèle, mais sans parler explicitement de mémoire off-heap. +
Voir tout particulièrement la section _The Internal Java Memory Model_
** https://anturis.com/blog/java-virtual-machine-the-essential-guide/ : bon schéma et explications sur le modèle mémoire Java (article récent, JDK 8)


  